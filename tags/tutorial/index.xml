<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial on norsey&#39;s hideout</title>
    <link>http://norsec0de.github.io/tags/tutorial/</link>
    <description>Recent content in tutorial on norsey&#39;s hideout</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Apr 2014 12:00:54 +0000</lastBuildDate><atom:link href="http://norsec0de.github.io/tags/tutorial/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>part 3: cleaning and optimising shellcode</title>
      <link>http://norsec0de.github.io/posts/part-3-cleaning-and-optimising-shellcode/</link>
      <pubDate>Thu, 24 Apr 2014 12:00:54 +0000</pubDate>
      
      <guid>http://norsec0de.github.io/posts/part-3-cleaning-and-optimising-shellcode/</guid>
      <description>In Part 2: Building the shellcode, we created a bind shell on port 4444 which accepts connections from any host and then interacts with /bin/sh to facilitate remote code execution. Our shellcode however was littered with null bytes and would probably not be very useful if embedding in any exploit code.
In this final part, we will clean our code and remove any null bytes from our shellcode. We will also look at removing unnecessary instruction to make our shellcode smaller if possible.</description>
    </item>
    
    <item>
      <title>part 2: building the shellcode</title>
      <link>http://norsec0de.github.io/posts/part-2-building-the-shellcode/</link>
      <pubDate>Thu, 24 Apr 2014 12:00:06 +0000</pubDate>
      
      <guid>http://norsec0de.github.io/posts/part-2-building-the-shellcode/</guid>
      <description>In Part 1: Disassembling and Understanding Shellcode we disassembled some shellcode and found out the steps required to create a bind shell. In Part 2, we will take each of these 6 steps, understand them and write assembly instructions to call them.
The steps we need to follow to create our bind shell are:
 Socket Bind Listen Accept Dup2 Execve  We are going to spend a lot of time working with NASM (The Netwide Assembler).</description>
    </item>
    
    <item>
      <title>part 1: disassembling and understanding shellcode</title>
      <link>http://norsec0de.github.io/posts/part-1-disassembling-and-understanding-shellcode/</link>
      <pubDate>Thu, 24 Apr 2014 11:58:47 +0000</pubDate>
      
      <guid>http://norsec0de.github.io/posts/part-1-disassembling-and-understanding-shellcode/</guid>
      <description>About a month ago I signed up for the Securitytube Linux Assembly Expert certification to get a deeper understanding of assembly and GDB. Doing so has helped me understand what is actually going on in the registers and not just relying on &amp;ldquo;hail-mary&amp;rdquo; advice like &amp;ldquo;use pop, pop, ret when dealing with SEH.&amp;rdquo; If you&amp;rsquo;re interested in Assembly or writing shellcode, I&amp;rsquo;d highly recommend you take the certification.</description>
    </item>
    
    <item>
      <title>decrypting base64 encrypted binary hashes</title>
      <link>http://norsec0de.github.io/posts/decrypting-base64-encrypted-binary-hashes/</link>
      <pubDate>Wed, 07 Nov 2012 09:18:43 +0000</pubDate>
      
      <guid>http://norsec0de.github.io/posts/decrypting-base64-encrypted-binary-hashes/</guid>
      <description>I came across a database while testing the other day which happily contained a table called users with the good old id, username and password fields. What made this a somewhat interesting find was the fact that the passwords appeared to be encrypted as base64.
After I stopped giggling I dumped the database and grabbed the first few hashes in an attempt to quickly script the decryption. The script ran fine although I ended up with a lot of garbled text and no plain text passwords.</description>
    </item>
    
  </channel>
</rss>
